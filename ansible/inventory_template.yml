---
# Ansible Inventory Template for GCP VM Patching
# This file shows the expected inventory structure that Terraform Actions
# will pass dynamically to AAP when triggering the patching job template.

# IMPORTANT: This is a TEMPLATE file for documentation purposes.
# The actual inventory is generated dynamically by Terraform Actions
# and passed to AAP via the API when the action is triggered.

all:
  hosts:
    # Example VM 1
    vm-ubuntu-1:
      ansible_host: 10.128.0.2          # Internal IP from GCP
      instance_id: "1234567890123456789" # GCP instance ID
      ansible_user: ubuntu
      ansible_ssh_private_key_file: "{{ vault_ssh_key }}"
      
    # Example VM 2
    vm-ubuntu-2:
      ansible_host: 10.128.0.3          # Internal IP from GCP
      instance_id: "9876543210987654321" # GCP instance ID
      ansible_user: ubuntu
      ansible_ssh_private_key_file: "{{ vault_ssh_key }}"
      
  vars:
    # Global variables for all hosts
    ansible_user: ubuntu
    ansible_become: yes
    ansible_become_method: sudo
    gcp_project: "your-gcp-project-id"
    environment: "demo"
    
    # SSH configuration
    ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
    
    # Patching configuration
    patch_type: "security"
    reboot_allowed: true
    reboot_timeout: 300

# How Terraform Actions Generates This Inventory:
# ================================================
# 
# In the Terraform Actions configuration (main.tf), the inventory is built
# dynamically from Terraform outputs:
#
# action "patch_vms" {
#   payload = {
#     inventory = jsonencode({
#       all = {
#         hosts = {
#           for vm in google_compute_instance.ubuntu_vms :
#           vm.name => {
#             ansible_host = vm.network_interface[0].network_ip
#             instance_id  = vm.instance_id
#           }
#         }
#         vars = {
#           ansible_user    = "ubuntu"
#           gcp_project     = var.gcp_project_id
#           environment     = var.environment
#           patch_type      = "security"
#           reboot_allowed  = true
#         }
#       }
#     })
#   }
# }
#
# This ensures the inventory always reflects the current state of
# provisioned VMs without manual updates.

# AAP Job Template Configuration:
# ===============================
# 
# When configuring the AAP job template:
# 1. Set "Prompt on launch" for INVENTORY
# 2. Set "Prompt on launch" for EXTRA VARIABLES
# 3. Configure Vault credential for SSH key retrieval
# 4. Link to the gcp_vm_patching.yml playbook
# 5. Enable "Allow simultaneous jobs" if needed
#
# The Terraform Action will pass this inventory structure via the
# /api/v2/job_templates/{id}/launch/ endpoint.

# Example API Payload from Terraform Actions:
# ============================================
# 
# POST /api/v2/job_templates/42/launch/
# {
#   "inventory": {
#     "all": {
#       "hosts": {
#         "vm-ubuntu-1": {
#           "ansible_host": "10.128.0.2",
#           "instance_id": "1234567890123456789"
#         },
#         "vm-ubuntu-2": {
#           "ansible_host": "10.128.0.3",
#           "instance_id": "9876543210987654321"
#         }
#       },
#       "vars": {
#         "ansible_user": "ubuntu",
#         "gcp_project": "my-project-id",
#         "environment": "demo"
#       }
#     }
#   },
#   "extra_vars": {
#     "patch_type": "security",
#     "reboot_allowed": true
#   }
# }

# Validation:
# ===========
# 
# To validate this inventory structure locally:
# 
# 1. Create a test inventory file with actual values:
#    cp inventory_template.yml inventory_test.yml
#    # Edit with real IPs and credentials
# 
# 2. Test connectivity:
#    ansible all -i inventory_test.yml -m ping
# 
# 3. Test playbook syntax:
#    ansible-playbook -i inventory_test.yml gcp_vm_patching.yml --syntax-check
# 
# 4. Dry run the playbook:
#    ansible-playbook -i inventory_test.yml gcp_vm_patching.yml --check

# Requirements Satisfied:
# =======================
# - Requirement 3.3: Actions configuration passes VM inventory data to AAP
# - Requirement 5.3: Job template accepts dynamic inventory from Terraform Actions
